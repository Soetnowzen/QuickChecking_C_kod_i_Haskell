<!DOCTYPE html>
<html hasbrowserhandlers="true"><head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">
  <meta name="viewport" content="width=device-width; user-scalable=0">

  <link rel="stylesheet" href="Bullet-proofing%20Helium%E2%80%99s%20embedded%20C%20code%20with%20Erlang%20QuickCheck-filer/aboutReader.css" type="text/css">

  <script type="text/javascript;version=1.8" src="Bullet-proofing%20Helium%E2%80%99s%20embedded%20C%20code%20with%20Erlang%20QuickCheck-filer/aboutReader.js"></script>
<link rel="stylesheet" href="Bullet-proofing%20Helium%E2%80%99s%20embedded%20C%20code%20with%20Erlang%20QuickCheck-filer/narrate.css"><title>Bullet-proofing Helium’s embedded C code with Erlang QuickCheck.</title></head>

<body class="loaded sepia sans-serif">
  <div id="container" class="container font-size5 content-width3">
    <div id="reader-header" class="header" style="display: block;">
      <style scoped="">
        @import url("chrome://global/skin/aboutReaderControls.css");
      </style>
      <a id="reader-domain" class="domain" href="https://blog.helium.com/quickcheck-and-the-deep-firmware-278f77cd2342#.k2796ai8k">blog.helium.com</a>
      <div class="domain-border"></div>
      <h1 id="reader-title">Bullet-proofing Helium’s embedded C code with Erlang QuickCheck.</h1>
      <div id="reader-credits" class="credits">Andrew Thompson</div>
    </div>

    <div class="content">
      <style scoped="">
        @import url("chrome://global/skin/aboutReaderContent.css");
      </style>
      <div id="moz-reader-content" class="line-height4" style="display: block;"><div id="readability-page-1" class="page" xml:base="https://blog.helium.com/quickcheck-and-the-deep-firmware-278f77cd2342#.k2796ai8k"><div role="main" class="postArticle-content js-postField js-notesSource js-trackedPost" data-post-id="278f77cd2342" data-source="post_page" data-collection-id="911a41543a61" data-tracking-context="postPage" data-scroll="native"><section name="d91e" class="section section--body section--first"><div class="section-content"><div class="section-inner layoutSingleColumn"><p name="9c47" id="9c47" class="graf graf--p graf-after--h3">At <a href="http://www.helium.com/" data-href="http://www.helium.com" class="markup--anchor markup--p-anchor" target="_blank">Helium</a>
 we build and manage end-to-end, smart sensing systems for various 
industrial and enterprise verticals. This means we have code spanning 
all the way from embedded device firmware to Web interfaces, and a bunch
 in-between. One of the challenges on the embedded side of the system is
 that testing can be harder because of the constraints of embedded 
programming. Have you ever had a cable modem or access point need to be 
rebooted for no reason? Yeah, this is one of the reasons why. I’m going 
to talk a little about how we at Helium want our devices in the field to
 ‘just work’ and avoid the ‘just reboot it’ approach to troubleshooting.</p><p name="f2cf" id="f2cf" class="graf graf--p graf-after--p">I
 was recently chasing some stack corruption issues in some of our 
firmware that was adjacent to one of the data structures the firmware 
uses; basically a circular buffer. I wondered if the scenario I was 
testing was related to a bug in that datastructure, so I decided to 
reach for a tool I’d never used before; <a href="http://www.quviq.com/products/quickcheck-for-c/" data-href="http://www.quviq.com/products/quickcheck-for-c/" class="markup--anchor markup--p-anchor" target="_blank">Erlang QuickCheck for C</a> (or EQC-C for short).</p><p name="6dc3" id="6dc3" class="graf graf--p graf-after--p">Quickcheck,
 for those unfamiliar, is a property-based testing tool. There are 
clones for it in several different languages these days, but it 
originated in Haskell (which we also <a href="https://www.youtube.com/watch?v=T2wi0ZUOHfM" data-href="https://www.youtube.com/watch?v=T2wi0ZUOHfM" class="markup--anchor markup--p-anchor" target="_blank">use at Helium</a>). <a href="http://www.quviq.com/" data-href="http://www.quviq.com/" class="markup--anchor markup--p-anchor" target="_blank">QuviQ</a> offers a commercial version for Erlang that provides a number of additional powerful features, one of them being EQC-C.</p><p name="050c" id="050c" class="graf graf--p graf-after--p">We’ve
 had a QuickCheck licence for a while, and we’ve used it to great effect
 in testing our Erlang-based, internal infrastructure and even black-box
 testing our firmware (that’s a blog post for another time). I had seen 
John Hughes talk about EQC-C but never had the chance to use it. This 
stack corruption issue was driving me nuts, however, so I decided it was
 time to try it out.</p><p name="8852" id="8852" class="graf graf--p graf-after--p graf--last">So,
 today I will be covering how you can QuickCheck C code. I won’t 
however, be using the code from our firmware. Instead, I will be showing
 you some EQC-C on some open source C datastructures that make for a 
cleaner and more interesting example (the circular buffer in the 
firmware turned out to be bug-free). Specifically, I will be testing the
 hashmap implementation from the open source video game remake I 
contribute to, <a href="https://github.com/omf2097/openomf" data-href="https://github.com/omf2097/openomf" class="markup--anchor markup--p-anchor" target="_blank">OpenOMF</a> (incidentally, we did use this hashmap for libhelium as well).</p></div></div></section><section name="8b32" class="section section--body"><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="8f08" id="8f08" class="graf graf--h4 graf--leading">Code to&nbsp;test</h4><p name="19ef" id="19ef" class="graf graf--p graf-after--h4">First of all, let’s take a look at the API we’ll be testing:</p><figure name="16f9" id="16f9" class="graf graf--figure graf--iframe graf-after--p"></figure><p name="b933" id="b933" class="graf graf--p graf-after--figure graf--last">As you can see, it is pretty straightforward. You can <strong class="markup--strong markup--p-strong">create</strong>, <strong class="markup--strong markup--p-strong">put</strong>, <strong class="markup--strong markup--p-strong">delete</strong>, <strong class="markup--strong markup--p-strong">iterate</strong> and <strong class="markup--strong markup--p-strong">clear</strong>
 the hashmap. So, how do we go about actually testing this? It turns 
out, EQC-C works by compiling your C code in some magical way that 
allows the C API to be wrapped in an Erlang module which then lets you 
write a regular EQC test to, well, test it.</p></div></div></section><section name="104c" class="section section--body"><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="cac5" id="cac5" class="graf graf--h4 graf--leading">Bridging the Erlang/C&nbsp;divide</h4><p name="8c35" id="8c35" class="graf graf--p graf-after--h4">The magic all begins with the <strong class="markup--strong markup--p-strong">eqc_c:start()</strong> function. In this case, it goes like this (at the Erlang REPL):</p><pre name="3d1b" id="3d1b" class="graf graf--pre graf-after--p">1&gt; eqc_c:start(hashmap, [{c_src, “hashmap.c”},<br>                         {cppflags, “-I ../../include/ -std=c99”},       <br>                         {cflags,”-lm”},<br>                         {additional_files, [“iterator.c”]}]).<br>Starting Quviq QuickCheck version 1.36.1<br> (compiled at {{2015,9,8},{9,10,49}})<br>Licence for Helium reserved until {{2016,1,6},{8,59,18}}<br>ok<br>2&gt;</pre><p name="5272" id="5272" class="graf graf--p graf-after--pre">There’s a bunch going on here, but basicially we tell it the C file we want to compile, set up some include paths, make sure we link it against the math library and also link in iterator.c, because the hashmap supports iteration.</p><p name="a084" id="a084" class="graf graf--p graf-after--p">Now, magically, we have a hashmap Erlang module that implements the C API:</p><pre name="34a2" id="34a2" class="graf graf--pre graf-after--p">2&gt; hashmap:&lt;tab&gt;<br>...<br>hashmap_clear/1 hashmap_create/2<br>hashmap_create_with_allocator/3 hashmap_del/3<br>hashmap_delete/2 hashmap_free/1<br>hashmap_get/5 hashmap_idel/2<br>hashmap_iget/4 hashmap_iput/4<br>hashmap_iter_begin/2 hashmap_iter_next/1<br>hashmap_put/5 hashmap_reserved/1<br>hashmap_sdel/2 hashmap_sget/4<br>hashmap_size/1 hashmap_sput/4<br>...</pre><p name="d4aa" id="d4aa" class="graf graf--p graf-after--pre graf--last">There’s actually a lot of other functions in this module, too. EQC-C has an option to only generate functions for the definitions in the C file, not the prototypes, but we will need some of the functions from iterator.c later, so we have to generate a bunch of extra functions.</p></div></div></section><section name="c6a1" class="section section--body"><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="57ca" id="57ca" class="graf graf--h4 graf--leading">Taking it for a&nbsp;spin</h4><p name="ee6c" id="ee6c" class="graf graf--p graf-after--h4">Now, we can actually use this as an Erlang module from the REPL, although it is a tad cumbersome because we need to use EQC-C’s C pointers:</p><pre name="a42d" id="a42d" class="graf graf--pre graf-after--p">2&gt; rr("hashmap.hrl").[allocator_t,div_t,hashmap_node_t,hashmap_pair_t,hashmap_t,<br> iterator_t,ldiv_t,lldiv_t]<br>3&gt; HM = eqc_c:alloc({struct, hashmap_t}).<br>{ptr,{struct,hashmap_t},20516928}<br>4&gt; hashmap:hashmap_create(HM, 6).<br>ok<br>5&gt; hashmap:hashmap_put(HM, eqc_c:create_string("hello"), 5, eqc_c:create_string("world"), 5).<br>{ptr,void,20517648}</pre><p name="8226" id="8226" class="graf graf--p graf-after--pre">So, there’s actually quite a bit going on here. First we read in the record definitions EQC-C generated from the structs it saw when compiling. Next, we actually allocate memory for one of those structures using eqc_c:alloc(). That returns a {ptr,&nbsp;…}, which is actually a handle for a C pointer. We can then use that pointer to call hashmap_create() to actually initialize a hashmap. Once we have initialized the hashmap, we can store something in it using hashmap_put(). To do so, we use an EQC-C helper function called create_string() which allocates a char* and initializes it to the string you provide it. hashmap_put also requires we specify the length of the parameters we pass (because it doesn’t assume the keys and values are null terminated), so we pass 5 in both cases. Once we do the put, we get back a pointer to the hashmap element we just created, just like the C API promises.</p><p name="b711" id="b711" class="graf graf--p graf-after--p">Now, to get something back <em class="markup--em markup--p-em">out</em> of the hashmap, it gets a little more complicated. Let’s look at the signature for hashmap_put again:</p><pre name="44b3" id="44b3" class="graf graf--pre graf-after--p">int hashmap_get(hashmap *hm, const void *key, unsigned int keylen, void **val, unsigned int *vallen);</pre><p name="d656" id="d656" class="graf graf--p graf-after--pre">So, it takes a void** and an unsigned int* pointer where it will fill in the address of the value for that key and its size. This is a little trickier to work with, and it took me a while to figure it out, but here’s how you do it:</p><pre name="33c8" id="33c8" class="graf graf--pre graf-after--p">6&gt; Val = eqc_c:alloc({ptr, unsigned_char}).<br>{ptr,{ptr,unsigned_char},10064640}<br>7&gt; ValLen = eqc_c:alloc(unsigned_int).<br>{ptr,unsigned_int,10064672}<br>8&gt; Res = hashmap:hashmap_get(HM, eqc_c:create_string("hello"), 5, Val, ValLen).<br>0</pre><p name="7ae2" id="7ae2" class="graf graf--p graf-after--pre">Ok, so we allocated a unsigned char** pointer and an unsigned int* pointer and passed them to the <strong class="markup--strong markup--p-strong">hashmap_get().</strong> The get returned 0, which is the success return code, so we ‘got’ something, but how do we look at it? EQC-C provides ways to read through a pointer (as well as cast pointers), so lets see what we got back:</p><pre name="e110" id="e110" class="graf graf--pre graf-after--p">9&gt; Len = eqc_c:deref(ValLen).<br>5<br>10&gt; eqc_c:read_array(eqc_c:deref(Val), Len).<br>"world"</pre><p name="674d" id="674d" class="graf graf--p graf-after--pre">There we go, it works! What happens if we try with a missing key?</p><pre name="1983" id="1983" class="graf graf--pre graf-after--p">13&gt; f(Len).<br>ok<br>14&gt; hashmap:hashmap_get(HM, eqc_c:create_string("nothere"), 7, Val, ValLen).<br>1<br>15&gt; Len = eqc_c:deref(ValLen).<br>0</pre><p name="7b01" id="7b01" class="graf graf--p graf-after--pre graf--last">Well, the return code from <strong class="markup--strong markup--p-strong">get()</strong> is now 1, which means the lookup failed, and the length pointer now holds 0, as expected.</p></div></div></section><section name="aa94" class="section section--body"><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="8824" id="8824" class="graf graf--h4 graf--leading">Let’s write a property!</h4><p name="cc46" id="cc46" class="graf graf--p graf-after--h4">So, this is all well and good, but how is this any better than a glorified FFI? Truth be told it really isn’t (aside from providing some nice isolation so segfaults don’t kill the Erlang VM), EQC-C is just a tool to let you unleash the power of Erlang QuickCheck on your C code, which is what this is all leading up to.</p><p name="4002" id="4002" class="graf graf--p graf-after--p">One of the tools in QuickCheck is called eqc_statem, the documentation describes it as such:</p><blockquote name="1f23" id="1f23" class="graf graf--pullquote graf-after--p">This module provides functions for testing operations with side-effects, which are specified via an abstract state&nbsp;machine.</blockquote><p name="1ade" id="1ade" class="graf graf--p graf-after--pullquote">Which is basically true. eqc_statem is a way to statefully test some component by generating ‘commands’ against that component and checking that your invariants hold. ‘Regular’ quickcheck is more about checking invariants for a particular function (does it work for all sorted arrays and fail for all unsorted arrays, etc). Most QuickCheck implementations are mostly about that simpler form of testing, but eqc_statem lets you test much more complicated systems at whatever granularity you want. You can test a whole system adheres to some invariants for some inputs, or in this case, you can test something smaller, like a datastructure.</p><p name="3a95" id="3a95" class="graf graf--p graf-after--p">eqc_statem works by defining callbacks for commands, generators for arguments for those commands, preconditions for those commands (if it is valid to generate this command at this point), postconditions where you test your invariants and ‘next state’ where you update your model’s state to reflect the changes the command made to the system under test.</p><p name="a177" id="a177" class="graf graf--p graf-after--p">Let’s take a look at what we would define for hashmap_create, the obvious starting point:</p><figure name="6930" id="6930" class="graf graf--figure graf--iframe graf-after--p"></figure><p name="9fa6" id="9fa6" class="graf graf--p graf-after--figure">So, we actually need to define a model state, so we have something to test our C code against. The state we need for this is actually very simple, it just holds a pointer to the hashmap, the size we created the hashmap with and an empty Erlang list that we will use to model the hashmap’s behaviour.</p><p name="f52b" id="f52b" class="graf graf--p graf-after--p">Our precondition simply says “only generate a hashmap if the hashmap in the the state is undefined”. This effectively forces EQC to generate this as the first command in any test. For the argument generator, we generate a number between 4 and 10 as the ‘size’ of the hashmap.</p><p name="ea56" id="ea56" class="graf graf--p graf-after--p">Then we have the actual create command itself, we allocate a hashmap_t, as before, and then we create a hashmap and return the pointer. The _next function simply updates our state by storing the pointer in the model’s state. Finally, because we don’t really have any invariants to test here, there’s no postcondition.</p><p name="df71" id="df71" class="graf graf--p graf-after--p">Now that we’ve seen a command modeled, let’s put it together with the boilerplate to make a QuickCheck property you can actually run:</p><figure name="08d0" id="08d0" class="graf graf--figure graf--iframe graf-after--p"></figure><p name="f54b" id="f54b" class="graf graf--p graf-after--figure">The only really interesting thing that’s new here is the property. It is saying “for all sets of generated commands, running the commands should not violate any invariants”. Because we don’t really have any invariants, it isn’t very interesting yet, but we can run it anyway:</p><pre name="9124" id="9124" class="graf graf--pre graf-after--p">1&gt; c(hashmap_eqc).<br>{ok,hashmap_eqc}<br>2&gt; eqc:quickcheck(hashmap_eqc:prop_correct()).<br>Starting Quviq QuickCheck version 1.36.1<br> (compiled at {{2015,9,8},{9,10,49}})<br>Licence for Helium reserved until {{2016,1,6},{8,59,18}}<br>……………………………………………………………………………………….<br>OK, passed 100 tests</pre><pre name="01da" id="01da" class="graf graf--pre graf-after--pre">100% {hashmap_eqc,hashmap_create,1}<br>true</pre><p name="699f" id="699f" class="graf graf--p graf-after--pre graf--last">So, we ran 100 tests, they all passed and the command we ran was hashmap_create 100% of the time. Not very interesting. Let’s model some more of the API.</p></div></div></section><section name="4091" class="section section--body"><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="c22f" id="c22f" class="graf graf--h4 graf--leading">Putting it on the&nbsp;line</h4><figure name="eb57" id="eb57" class="graf graf--figure graf--iframe graf-after--h4"></figure><p name="90a3" id="90a3" class="graf graf--p graf-after--figure">Now that we are modeling <strong class="markup--strong markup--p-strong">put()</strong> it’s starting to get interesting. The precondition to put is that we have a hashmap created, so the hashmap element of the model state can’t be undefined. That is pretty straightforward. Next, using the argument generator, we’re generating 3 arguments; the pointer to the hashmap, the key and the value. We want to generate keys that don’t already appear in the hashmap, so we use the <strong class="markup--strong markup--p-strong">SUCHTHAT</strong> macro to say we want a non-empty list of char()s that are not already in the list of keys in the model state and that the value should also not be empty.</p><p name="c481" id="c481" class="graf graf--p graf-after--p">The actual command function, <strong class="markup--strong markup--p-strong">hashmap_put</strong>, takes those generated arguments and actually does the put, as we’ve seen before. I’m being careful to clean up after myself now though so we don’t leak memory. The return value from the command is the return value from the actual C function <strong class="markup--strong markup--p-strong">hashmap_put</strong> (although in this case we don’t use it).</p><p name="4cdd" id="4cdd" class="graf graf--p graf-after--p">Finally, the next function prepends the {Key, Value} tuple to our list that we are using to model the state of the hashmap.</p><p name="8286" id="8286" class="graf graf--p graf-after--p">If we go ahead and add that to what we had before (along with the relevant export directives) we see something like this:</p><pre name="55dd" id="55dd" class="graf graf--pre graf-after--p">eqc:quickcheck(hashmap_eqc:prop_correct()).<br>……………………………………………………………………………………….<br>OK, passed 100 tests</pre><pre name="143c" id="143c" class="graf graf--pre graf-after--pre">91.7% {hashmap_eqc,hashmap_put,3}<br>8.3% {hashmap_eqc,hashmap_create,1}<br>true</pre><p name="a3ba" id="a3ba" class="graf graf--p graf-after--pre graf--last">Because we can only call <strong class="markup--strong markup--p-strong">hashmap_create</strong> if there isn’t already a hashmap, the hashmap_put now dominates the distribution of the commands generated. We still don’t have any postconditions to check our invariants, so everything passes. So lets add something we can actually test, like <strong class="markup--strong markup--p-strong">get()</strong>.</p></div></div></section><section name="edc4" class="section section--body"><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="5cbf" id="5cbf" class="graf graf--h4 graf--leading">Getting serious</h4><figure name="2cb5" id="2cb5" class="graf graf--figure graf--iframe graf-after--h4"></figure><p name="82a2" id="82a2" class="graf graf--p graf-after--figure">Ok, there is a lot more going on here, let’s break it down.</p><p name="05b8" id="05b8" class="graf graf--p graf-after--p">We have seen this precondition before. Nothing too interesting. Our argument generator has 2 clauses, one for when we have keys in the hashmap, and one for when we don’t. When we DO have keys in the hashmap we pick one of the keys out of the model we know we’ve stored, but we also have a chance to generate keys that may NOT appear in the hashmap, so we can test failed lookups as well. When the hashmap is empty, we just try with a random key.</p><p name="7372" id="7372" class="graf graf--p graf-after--p">The actual command function, again, is similar to what we did on the REPL earlier. From the command function, we return a 3 tuple containing the result of the C function, the value of the returned length, and the value returned from the hashmap lookup (or undefined, if the length was 0).</p><p name="6460" id="6460" class="graf graf--p graf-after--p">Now, finally, we have a postcondition. The postcondition says that if the key was expected to be in the hashmap, the return code should be 0 and the value read out of the hashmap should be the same as we had stored in the model. If the key is NOT in the hashmap, we expect the return code to be 1 and the returned length to be 0.</p><p name="2ebe" id="2ebe" class="graf graf--p graf-after--p graf--last">If we put that together with what we had before and run it, well, everything still passes. I guess the hashmap does the basics well.</p></div></div></section><section name="fb54" class="section section--body"><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="6aba" id="6aba" class="graf graf--h4 graf--leading">Forgetting things</h4><p name="0b95" id="0b95" class="graf graf--p graf-after--h4">Let’s model clear() next, it will be easy:</p><figure name="d909" id="d909" class="graf graf--figure graf--iframe graf-after--p"></figure><p name="4855" id="4855" class="graf graf--p graf-after--figure">Super simple - all we do is call clear and set our model to have the empty list as the model for the map. This means that any lookups AFTER a clear is done should return nothing. Again, as expected, if we update the test, everything passes. Let’s do delete:</p><figure name="67ce" id="67ce" class="graf graf--figure graf--iframe graf-after--p"></figure><p name="d36c" id="d36c" class="graf graf--p graf-after--figure">The argument generator here is similar to the one for <strong class="markup--strong markup--p-strong">get()</strong>. If the map isn’t empty we pick a key from the map or a random key; if the map is empty we generate a random key. The command is straightforward, the postcondition just checks if the return code is 0 if the key was in the hashmap, and 1 if it was not, and the _next function deletes the key we deleted from our model.</p><p name="6c90" id="6c90" class="graf graf--p graf-after--p">Lets put all this together and run 1000 tests:</p><pre name="32b9" id="32b9" class="graf graf--pre graf-after--p">eqc:quickcheck(eqc:numtests(1000, hashmap_eqc:prop_correct())).<br>……………………………………………………………………………………….(x10)………………………………………………………………………………<br>OK, passed 1000 tests</pre><pre name="2e16" id="2e16" class="graf graf--pre graf-after--pre graf--last">23.94% {hashmap_eqc,hashmap_get,2}<br>23.62% {hashmap_eqc,hashmap_delete,2}<br>23.24% {hashmap_eqc,hashmap_put,3}<br>23.10% {hashmap_eqc,hashmap_clear,1}<br>6.10% {hashmap_eqc,hashmap_create,1}<br>true</pre></div></div></section><section name="26e2" class="section section--body"><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="5c65" id="5c65" class="graf graf--h4 graf--leading">Taking a walk through a&nbsp;hashmap</h4><p name="cb6f" id="cb6f" class="graf graf--p graf-after--h4">Everything still passes and we’re generating a good mix of operations against the hashmap. What else can we test? The two interesting functions remaining are both of the iteration functions, <strong class="markup--strong markup--p-strong">hashmap_iter_begin</strong> and <strong class="markup--strong markup--p-strong">hashmap_delete</strong> (which takes an iterator). Let’s use the iterator to dump the state of the hash and compare every key in there to our model:</p><figure name="40fc" id="40fc" class="graf graf--figure graf--iframe graf-after--p"></figure><p name="ebd7" id="ebd7" class="graf graf--p graf-after--figure graf--last">So, we actually needed a helper function here to walk the iterator until we hit NULL, which indicates the end of the hash. We are also making use of <strong class="markup--strong markup--p-strong">cast_ptr</strong> here to cast the void pointers we get back from <strong class="markup--strong markup--p-strong">iter_next()</strong> into the relevant types so we can extract the key/value pairs. Once we hit NULL, we return the accumulated list of 2-tuples and use that as the return from our command function. The postcondition compares if the sorted model list matches the sorted list we dumped from the hashmap.</p></div></div></section><section name="a96f" class="section section--body"><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="8228" id="8228" class="graf graf--h4 graf--leading">Pigeon hole&nbsp;problem</h4><p name="829d" id="829d" class="graf graf--p graf-after--h4">However, even with all that ingenuity we still have no failures. What if we intentionally try to orphan values by overwriting existing keys? It would look a little something like this:</p><figure name="0164" id="0164" class="graf graf--figure graf--iframe graf-after--p"></figure><p name="d31e" id="d31e" class="graf graf--p graf-after--figure">So, we generate a key and value pair to <strong class="markup--strong markup--p-strong">put()</strong> that intentionally generates the key as one of the keys already in the hashmap, and the generated value must NOT already be present in the hashmap. This will give us a good way to see what happens when we ‘update’ a key in the hashmap.</p><p name="48f3" id="48f3" class="graf graf--p graf-after--p">Let’s run it and see what happens:</p><pre name="fd39" id="fd39" class="graf graf--pre graf-after--p">10&gt; eqc:quickcheck(eqc:numtests(1000, hashmap_eqc:prop_correct())).<br>..Failed! After 3 tests.<br>[{set,{var,1},{call,hashmap_eqc,hashmap_create,”\n”}},<br> {set,{var,2},{call,hashmap_eqc,hashmap_get,[{var,1},”±”]}},<br> {set,{var,3},{call,hashmap_eqc,hashmap_compare,[{var,1}]}},<br> {set,{var,4},{call,hashmap_eqc,hashmap_get,[{var,1},”õ”]}},<br> {set,{var,5},{call,hashmap_eqc,hashmap_compare,[{var,1}]}},<br> {set,{var,6},{call,hashmap_eqc,hashmap_delete,[{var,1},”\””]}},<br> {set,{var,7},{call,hashmap_eqc,hashmap_compare,[{var,1}]}},<br> {set,{var,8},{call,hashmap_eqc,hashmap_compare,[{var,1}]}},<br> {set,{var,9},{call,hashmap_eqc,hashmap_clear,[{var,1}]}},<br> {set,{var,10},{call,hashmap_eqc,hashmap_clear,[{var,1}]}},<br> {set,{var,11},{call,hashmap_eqc,hashmap_put,[{var,1},”y”,”T”]}},<br> {set,{var,12},{call,hashmap_eqc,hashmap_replace,[{var,1},”y”,”j”]}},<br> {set,{var,13},{call,hashmap_eqc,hashmap_compare,[{var,1}]}},<br> {set,{var,14},{call,hashmap_eqc,hashmap_get,[{var,1},[155]]}},<br> {set,{var,15},{call,hashmap_eqc,hashmap_clear,[{var,1}]}},<br> {set,{var,16},{call,hashmap_eqc,hashmap_put,[{var,1},”º”,”r”]}},<br> {set,{var,17},{call,hashmap_eqc,hashmap_compare,[{var,1}]}},<br> {set,{var,18},{call,hashmap_eqc,hashmap_put,[{var,1},”Ý”,”ä”]}}]</pre><pre name="cd08" id="cd08" class="graf graf--pre graf-after--pre">hashmap_eqc:hashmap_create(10) -&gt; {ptr, {struct, hashmap_t}, 18817040}<br>hashmap_eqc:hashmap_get({ptr, {struct, hashmap_t}, 18817040}, “±”) -&gt;<br> {1, 0, undefined}<br>hashmap_eqc:hashmap_compare({ptr, {struct, hashmap_t}, 18817040}) -&gt; []<br>hashmap_eqc:hashmap_get({ptr, {struct, hashmap_t}, 18817040}, “õ”) -&gt;<br> {1, 0, undefined}<br>hashmap_eqc:hashmap_compare({ptr, {struct, hashmap_t}, 18817040}) -&gt; []<br>hashmap_eqc:hashmap_delete({ptr, {struct, hashmap_t}, 18817040}, “\””) -&gt; 1<br>hashmap_eqc:hashmap_compare({ptr, {struct, hashmap_t}, 18817040}) -&gt; []<br>hashmap_eqc:hashmap_compare({ptr, {struct, hashmap_t}, 18817040}) -&gt; []<br>hashmap_eqc:hashmap_clear({ptr, {struct, hashmap_t}, 18817040}) -&gt; ok<br>hashmap_eqc:hashmap_clear({ptr, {struct, hashmap_t}, 18817040}) -&gt; ok<br>hashmap_eqc:hashmap_put({ptr, {struct, hashmap_t}, 18817040}, “y”, “T”) -&gt;<br> {ptr, void, 18825440}<br>hashmap_eqc:hashmap_replace({ptr, {struct, hashmap_t}, 18817040}, “y”, “j”) -&gt;<br> {ptr, void, 18825552}<br>hashmap_eqc:hashmap_compare({ptr, {struct, hashmap_t}, 18817040}) -&gt;<br> [{“y”, “T”}, {“y”, “j”}]</pre><pre name="7062" id="7062" class="graf graf--pre graf-after--pre">Reason:<br> Post-condition failed:<br> {hash_mismatch, [{“y”, “j”}], [{“y”, “T”}, {“y”, “j”}]}<br>{postcondition,{hash_mismatch,[{“y”,”j”}],[{“y”,”T”},{“y”,”j”}]}} /= ok<br>false</pre><p name="7d11" id="7d11" class="graf graf--p graf-after--pre">Yes! A counterexample! We’ve found a bug. We expected the hashmap to contain [{“y”, “j”}] but it actually contained [{“y”, “T”}, {“y”, “j”}], we had 2 values for the “y” key. This is a bug (at least in how we choose to define the semantics of this hashmap). If we go look at the <a href="https://github.com/omf2097/openomf/blob/4eca9e4e4c606121678beb79a9fa7988e12e1eed/src/utils/hashmap.c#L140-L162" data-href="https://github.com/omf2097/openomf/blob/4eca9e4e4c606121678beb79a9fa7988e12e1eed/src/utils/hashmap.c#L140-L162" class="markup--anchor markup--p-anchor" target="_blank">hashmap_put()</a> function implementation, we see that it doesn’t clear out any previous value under that key. I reported this to the author and he made <a href="https://github.com/omf2097/openomf/commit/a941e52f6e524ab15323366dfa40014fd8adf6aa" data-href="https://github.com/omf2097/openomf/commit/a941e52f6e524ab15323366dfa40014fd8adf6aa" class="markup--anchor markup--p-anchor" target="_blank">this commit</a> to fix it and test for this scenario, lets try it:</p><pre name="d2a2" id="d2a2" class="graf graf--pre graf-after--p">3&gt; eqc:check(hashmap_eqc:prop_correct()).<br>OK, passed the test.<br>true</pre><p name="1333" id="1333" class="graf graf--p graf-after--pre">eqc:check() will re-run the last counterexample for the given property, so once you find a failure, you can test only that failure until you’ve fixed it. Bug squashed. Let’s run some more tests to be sure…</p><pre name="1355" id="1355" class="graf graf--pre graf-after--p">hashmap_eqc:hashmap_create(9) -&gt; {ptr, {struct, hashmap_t}, 89178928}<br>hashmap_eqc:hashmap_delete({ptr, {struct, hashmap_t}, 89178928}, [159, 166, 202]) -&gt; 1<br>hashmap_eqc:hashmap_delete({ptr, {struct, hashmap_t}, 89178928}, [1]) -&gt; 1<br>hashmap_eqc:hashmap_put({ptr, {struct, hashmap_t}, 89178928}, [19], “{²”) -&gt;<br> {ptr, void, 89183696}<br>hashmap_eqc:hashmap_iter_delete({ptr, {struct, hashmap_t}, 89178928}, [28, 92, 116]) -&gt; 1<br>hashmap_eqc:hashmap_clear({ptr, {struct, hashmap_t}, 89178928}) -&gt; ok<br>hashmap_eqc:hashmap_iter_delete({ptr, {struct, hashmap_t}, 89178928}, “È”) -&gt; 1<br>hashmap_eqc:hashmap_clear({ptr, {struct, hashmap_t}, 89178928}) -&gt; ok<br>hashmap_eqc:hashmap_put({ptr, {struct, hashmap_t}, 89178928}, “;”, “OÀO”) -&gt;<br> {ptr, void, 89184336}<br>hashmap_eqc:hashmap_replace({ptr, {struct, hashmap_t}, 89178928}, “;”, “´S”) -&gt;<br> {ptr, void, 89184576}<br>hashmap_eqc:hashmap_put({ptr, {struct, hashmap_t}, 89178928}, [3, 208], “ðE”) -&gt;<br> {ptr, void, 89184992}<br>hashmap_eqc:hashmap_get({ptr, {struct, hashmap_t}, 89178928}, [142, 227, 49]) -&gt;<br> {1, 0, undefined}<br>hashmap_eqc:hashmap_compare({ptr, {struct, hashmap_t}, 89178928}) -&gt;<br> [{“;”, [180, 83, 0]}, {[3, 208], “ðE”}]</pre><pre name="6b4d" id="6b4d" class="graf graf--pre graf-after--pre">Reason:<br> Post-condition failed:<br> {hash_mismatch, [{[3, 208], “ðE”}, {“;”, “´S”}],<br> [{[3, 208], “ðE”}, {“;”, [180, 83, 0]}]}<br>{postcondition,{hash_mismatch,[{[3,208],”ðE”},{“;”,”´S”}],<br> [{[3,208],”ðE”},{“;”,[180,83,0]}]}} /= ok<br>false<br>5&gt; [180, 83].<br>“´S”</pre><p name="c2a8" id="c2a8" class="graf graf--p graf-after--pre graf--last">Oh, so now a value has a random null byte appended.. what? It turns out the fix just reallocs the value, but doesn’t reset the value length, so we’re reading past the length of the value into undefined memory. That’s bad. I pushed a <a href="https://github.com/omf2097/openomf/commit/ebfc123caf4dd9a4300e86a48606670a8313d0fa" data-href="https://github.com/omf2097/openomf/commit/ebfc123caf4dd9a4300e86a48606670a8313d0fa" class="markup--anchor markup--p-anchor" target="_blank">fix to the fix.</a></p></div></div></section><section name="effb" class="section section--body"><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="71da" id="71da" class="graf graf--h4 graf--leading">Deletes, one more&nbsp;time</h4><p name="4247" id="4247" class="graf graf--p graf-after--h4">There’s not much more interesting to test. The weird flavors of put/get are just ones that auto cast the type for you. The only interesting function left is really hashmap_delete() which is what you use to delete while you’re iterating over the hashmap. Let’s model that command.</p><figure name="1722" id="1722" class="graf graf--figure graf--iframe graf-after--p"></figure><p name="4db4" id="4db4" class="graf graf--p graf-after--figure">So, again, we generate a key like we did for put and del, but this time we iterate the hash until we find that key and then we pass the iterator at that point to hashmap_delete. In the postcondition we check the return value was as-expected, existant keys should return 0, non-existant keys should return 1 (if we fall of the end of the iterator, we try to delete the iterator anyway). The next_state function deletes the key from the map.</p><p name="53d3" id="53d3" class="graf graf--p graf-after--p">Lets put that all together and run it now:</p><pre name="6999" id="6999" class="graf graf--pre graf-after--p">OK, passed 1000 tests</pre><pre name="4b16" id="4b16" class="graf graf--pre graf-after--pre graf--last">15.28% {hashmap_eqc,hashmap_compare,1}<br>15.13% {hashmap_eqc,hashmap_iter_delete,2}<br>14.99% {hashmap_eqc,hashmap_get,2}<br>14.97% {hashmap_eqc,hashmap_clear,1}<br>14.92% {hashmap_eqc,hashmap_delete,2}<br>14.49% {hashmap_eqc,hashmap_put,3}<br>5.63% {hashmap_eqc,hashmap_create,1}<br>4.59% {hashmap_eqc,hashmap_replace,3}<br>true</pre></div></div></section><section name="785d" class="section section--body"><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="96ab" id="96ab" class="graf graf--h4 graf--leading">Checking for&nbsp;leaks</h4><p name="bf77" id="bf77" class="graf graf--p graf-after--h4">Well, I guess that works as expected, too. What about checking for memory leaks? EQC-C has a cool way to run the generated C program under a wrapper command, lets try that. Just add</p><pre name="74fd" id="74fd" class="graf graf--pre graf-after--p">{exec_command_line, fun(Exe) -&gt; {os:find_executable("valgrind"), ["--leak-check=full", Exe]} end}</pre><p name="2f40" id="2f40" class="graf graf--p graf-after--pre">To the end of the eqc_c:start parameter list to run the command under valgrind. Lets do a nice long run, too, like 15 minutes:</p><pre name="67d9" id="67d9" class="graf graf--pre graf-after--p">eqc:quickcheck(eqc:testing_time(900, hashmap_eqc:prop_correct())).</pre><pre name="4da8" id="4da8" class="graf graf--pre graf-after--pre">==23954== Invalid read of size 8<br>==23954== at 0x41F52D: hashmap_delete (hashmap.c:461)<br>==23954== by 0x41387A: __eqc_c_wrapper_hashmap_delete (__eqc_tmp145296883325291_wrapper.c:3574)<br>==23954== by 0x4253ED: __eqc_c_interpreter_loop (eqc_c_lib.c:620)<br>==23954== by 0x42556F: __eqc_c_interpreter (eqc_c_lib.c:639)<br>==23954== by 0x41C39B: main (__eqc_tmp145296883325291_wrapper.c:5970)<br>==23954== Address 0x6bb0cf8 is 8 bytes before a block of size 2,048 alloc’d<br>==23954== at 0x4C28C10: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)<br>==23954== by 0x41C752: hashmap_create_with_allocator (hashmap.c:59)<br>==23954== by 0x41C8AB: hashmap_create (hashmap.c:81)<br>==23954== by 0x4135A2: __eqc_c_wrapper_hashmap_create (__eqc_tmp145296883325291_wrapper.c:3537)<br>==23954== by 0x4253ED: __eqc_c_interpreter_loop (eqc_c_lib.c:620)<br>==23954== by 0x42556F: __eqc_c_interpreter (eqc_c_lib.c:639)<br>==23954== by 0x41C39B: main (__eqc_tmp145296883325291_wrapper.c:5970)</pre><pre name="670c" id="670c" class="graf graf--pre graf-after--pre">Time limit reached: 900.0 seconds.</pre><pre name="1130" id="1130" class="graf graf--pre graf-after--pre">OK, passed 39965 tests</pre><pre name="04fb" id="04fb" class="graf graf--pre graf-after--pre">14.9205% {hashmap_eqc,hashmap_put,3}<br>14.8869% {hashmap_eqc,hashmap_get,2}<br>14.8748% {hashmap_eqc,hashmap_clear,1}<br>14.8599% {hashmap_eqc,hashmap_compare,1}<br>14.8477% {hashmap_eqc,hashmap_delete,2}<br>14.8462% {hashmap_eqc,hashmap_iter_delete,2}<br>6.0068% {hashmap_eqc,hashmap_create,1}<br>4.7573% {hashmap_eqc,hashmap_replace,3}<br>true<br>3&gt;<br>User switch command<br> → q<br>==22494== [../src/utils]<br>==22494== HEAP SUMMARY:<br>==22494== in use at exit: 0 bytes in 0 blocks<br>==22494== total heap usage: 1,244,999 allocs, 1,244,999 frees, 105,542,040 bytes allocated<br>==22494==<br>==22494== All heap blocks were freed — no leaks are possible<br>==22494==<br>==22494== For counts of detected and suppressed errors, rerun with: -v<br>==22494== ERROR SUMMARY: 62690 errors from 1 contexts (suppressed: 0 from 0)</pre><p name="329b" id="329b" class="graf graf--p graf-after--pre">Uh oh, invalid read of size 8 in hashmap_delete, what is causing that? Turns out passing an ‘ended’ iterator to hashmap_delete causes an invalid read. We can <a href="https://github.com/omf2097/openomf/commit/32d93f0c09e901a33f79a95462ebd0730a28dc51" data-href="https://github.com/omf2097/openomf/commit/32d93f0c09e901a33f79a95462ebd0730a28dc51" class="markup--anchor markup--p-anchor" target="_blank">fix that</a> pretty easily, and then the run is clean.</p><p name="3cac" id="3cac" class="graf graf--p graf-after--p graf--last">Now, other than doing a lot of allocations/frees (which is expected), everything looks good. This is why I was so careful to clean up after all my allocations earlier. I wanted to be able to check if the datastructure had any leaks in it.</p></div></div></section><section name="4c71" class="section section--body"><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="30ac" id="30ac" class="graf graf--h4 graf--leading">Looking for bad behavior &amp; checking&nbsp;coverage</h4><p name="9b28" id="9b28" class="graf graf--p graf-after--h4">What about checking for C undefined behaviour, or if there’s any buffer overruns on the stack? We can add these to the cflags for eqc_c start:</p><pre name="e590" id="e590" class="graf graf--pre graf-after--p">-fsanitize=undefined -fno-sanitize-recover -fstack-protector-strong</pre><p name="58c3" id="58c3" class="graf graf--p graf-after--pre">This will cause the program to abort on undefined behaviour and also install red zones between things on the stack so overruns will cause an unmapped page fault and crash the program. We can also get some numbers on how many times each line is being hit using these cflags:</p><pre name="4e83" id="4e83" class="graf graf--pre graf-after--p">-fprofile-arcs -ftest-coverage</pre><p name="a2f5" id="a2f5" class="graf graf--p graf-after--pre">One more run:</p><pre name="9b82" id="9b82" class="graf graf--pre graf-after--p">Time limit reached: 900.0 seconds.</pre><pre name="a2a0" id="a2a0" class="graf graf--pre graf-after--pre">OK, passed 37209 tests</pre><pre name="d4c1" id="d4c1" class="graf graf--pre graf-after--pre">14.9676% {hashmap_eqc,hashmap_clear,1}<br>14.9604% {hashmap_eqc,hashmap_compare,1}<br>14.8948% {hashmap_eqc,hashmap_iter_delete,2}<br>14.8553% {hashmap_eqc,hashmap_get,2}<br>14.8513% {hashmap_eqc,hashmap_delete,2}<br>14.7747% {hashmap_eqc,hashmap_put,3}<br>5.9534% {hashmap_eqc,hashmap_create,1}<br>4.7425% {hashmap_eqc,hashmap_replace,3}<br>true<br>4&gt;<br>User switch command<br> → q<br>^andrew@macbookpro:: ==27754== [../src/utils]<br>==27754== HEAP SUMMARY:<br>==27754== in use at exit: 72,704 bytes in 1 blocks<br>==27754== total heap usage: 1,107,152 allocs, 1,107,151 frees, 97,994,853 bytes allocated<br>==27754==<br>==27754== LEAK SUMMARY:<br>==27754== definitely lost: 0 bytes in 0 blocks<br>==27754== indirectly lost: 0 bytes in 0 blocks<br>==27754== possibly lost: 0 bytes in 0 blocks<br>==27754== still reachable: 72,704 bytes in 1 blocks<br>==27754== suppressed: 0 bytes in 0 blocks<br>==27754== Reachable blocks (those to which a pointer was found) are not shown.<br>==27754== To see them, rerun with: — leak-check=full — show-leak-kinds=all<br>==27754==<br>==27754== For counts of detected and suppressed errors, rerun with: -v<br>==27754== ERROR SUMMARY: 59201 errors from 1 contexts (suppressed: 0 from 0)</pre><p name="6ea1" id="6ea1" class="graf graf--p graf-after--pre">And let’s look at the coverage:</p><pre name="bdca" id="bdca" class="graf graf--pre graf-after--p">$ gcov hashmap.c<br>File ‘hashmap.c’<br>Lines executed:89.25% of 186<br>Creating ‘hashmap.c.gcov’</pre><p name="ae3f" id="ae3f" class="graf graf--p graf-after--pre graf--last"><a href="https://gist.github.com/Vagabond/f4d44f376b22bb169c4c" data-href="https://gist.github.com/Vagabond/f4d44f376b22bb169c4c" class="markup--anchor markup--p-anchor" target="_blank">Here’s the report</a>. Lines are prefixed by the # of times they’re called. Lines with no code are prefixed by dashes and unreachable lines are prefixed by #####. The only unreached lines I’m actually worried about are 346 and 368. 346 is reachable if you do silly things with iterators (like double iterate, delete with one iterator and try to delete with the second). 368 is, I think, dead code.</p></div></div></section><section name="c356" class="section section--body section--last"><div class="section-content"><div class="section-inner layoutSingleColumn"><h4 name="d171" id="d171" class="graf graf--h4 graf--leading">End of the&nbsp;road</h4><p name="173f" id="173f" class="graf graf--p graf-after--h4">Here’s the <a href="https://gist.github.com/Vagabond/04508270fa6f81dbba19" data-href="https://gist.github.com/Vagabond/04508270fa6f81dbba19" class="markup--anchor markup--p-anchor" target="_blank">final EQC test</a>. The real beauty of this is that unlike a regular test suite, you can have it run millions of generated tests. In fact, I usually don’t consider an EQC test done unless it has passed a million iterations at least. I’ve often found crazy bugs after 750,000 tests that turned out to be legitimate and the kind of bug that if you saw it happen in production you’d ascribe to cosmic rays flipping bits or something. Once you teach EQC about the system under test, it can test that system endlessly. You don’t have to spend a lot of time thinking about really evil edge cases to turn into unit tests, EQC uses the basic knowledge about the system to find those edge cases for you.</p><p name="badb" id="badb" class="graf graf--p graf-after--p graf--last">If you’re interested in more information, <a href="http://quviq.com/" data-href="http://quviq.com" class="markup--anchor markup--p-anchor" target="_blank">QuviQ’</a>s site has a lot more information, documentation, case studies, blog posts and videos. You can also download EQC-mini, which has similar features to the Haskell QuickCheck (no eqc_statem or EQC-C). You can also look into recent Helium hire, Scott Vokes’ <a href="https://github.com/silentbicycle/theft" data-href="https://github.com/silentbicycle/theft" class="markup--anchor markup--p-anchor" target="_blank">theft</a>, which is like QuickCheck in C, or Helium veteran Reid Draper’s <a href="https://github.com/clojure/test.check" data-href="https://github.com/clojure/test.check" class="markup--anchor markup--p-anchor" target="_blank">test.check</a> for Clojure. There’s also probably a QuickCheck clone for your favorite language, too.</p></div></div></section></div></div></div>
    </div>

    <div>
      <style scoped="">
        @import url("chrome://global/skin/aboutReaderControls.css");
      </style>
      <div id="reader-message" style="display: none;"></div>
    </div>
  </div>

  <ul id="reader-toolbar" class="toolbar">
    <style scoped="">
      @import url("chrome://global/skin/aboutReaderControls.css");
    </style>
    <li><button id="close-button" class="button close-button" title="Stäng läsarvy"></button></li>
    <ul id="style-dropdown" class="dropdown">
      <li><button class="dropdown-toggle button style-button" title="Typkontroller"></button></li>
      <li id="reader-popup" class="dropdown-popup" style="top: 48px;">
        <div id="font-type-buttons"><button class="sans-serif-button selected"><div class="name">Aa</div><div class="description">Sans-serif</div></button><button class="serif-button"><div class="name">Aa</div><div class="description">Serif</div></button></div>
        <hr>
        <div id="font-size-buttons">
          <button id="font-size-minus" class="minus-button">
          </button><button id="font-size-sample">Aa</button><button id="font-size-plus" class="plus-button">
        </button></div>
        <hr>
        <div id="content-width-buttons">
          <button id="content-width-minus" class="content-width-minus-button">
          </button><button id="content-width-plus" class="content-width-plus-button">
        </button></div>
        <hr>
        <div id="line-height-buttons">
          <button id="line-height-minus" class="line-height-minus-button">
          </button><button id="line-height-plus" class="line-height-plus-button">
        </button></div>
        <hr>
        <div id="color-scheme-buttons"><button class="light-button"><div class="name">Ljus</div></button><button class="dark-button"><div class="name">Mörk</div></button><button class="sepia-button selected"><div class="name">Sepia</div></button></div>
        <div class="dropdown-arrow">
      </div></li>
    </ul>
  <ul class="dropdown" id="narrate-dropdown"><style scoped="">
      @import url("chrome://global/skin/narrateControls.css");
    </style>
    <li>
       <button class="dropdown-toggle button" id="narrate-toggle" title="Berätta">
         <svg xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" width="24" height="24" viewBox="0 0 24 24">
          <style>
            @keyframes grow {
              0%   { transform: scaleY(1);   }
              15%  { transform: scaleY(1.5); }
              15%  { transform: scaleY(1.5); }
              30%  { transform: scaleY(1);   }
              100% { transform: scaleY(1);   }
            }

            #waveform &gt; rect {
              fill: #808080;
            }

            .speaking #waveform &gt; rect {
              fill: #58bf43;
              transform-box: fill-box;
              transform-origin: 50% 50%;
              animation-name: grow;
              animation-duration: 1750ms;
              animation-iteration-count: infinite;
              animation-timing-function: linear;
            }

            #waveform &gt; rect:nth-child(2) { animation-delay: 250ms; }
            #waveform &gt; rect:nth-child(3) { animation-delay: 500ms; }
            #waveform &gt; rect:nth-child(4) { animation-delay: 750ms; }
            #waveform &gt; rect:nth-child(5) { animation-delay: 1000ms; }
            #waveform &gt; rect:nth-child(6) { animation-delay: 1250ms; }
            #waveform &gt; rect:nth-child(7) { animation-delay: 1500ms; }

          </style>
          <g id="waveform">
            <rect x="1" y="8" width="2" height="8" rx=".5" ry=".5"></rect>
            <rect x="4" y="5" width="2" height="14" rx=".5" ry=".5"></rect>
            <rect x="7" y="8" width="2" height="8" rx=".5" ry=".5"></rect>
            <rect x="10" y="4" width="2" height="16" rx=".5" ry=".5"></rect>
            <rect x="13" y="2" width="2" height="20" rx=".5" ry=".5"></rect>
            <rect x="16" y="4" width="2" height="16" rx=".5" ry=".5"></rect>
            <rect x="19" y="7" width="2" height="10" rx=".5" ry=".5"></rect>
          </g>
         </svg>
        </button>
    </li>
    <li class="dropdown-popup">
      <div id="narrate-control" class="narrate-row">
        <button disabled="disabled" id="narrate-skip-previous" title="Tillbaka"></button>
        <button id="narrate-start-stop" title="Börja"></button>
        <button disabled="disabled" id="narrate-skip-next" title="Framåt"></button>
      </div>
      <div id="narrate-rate" class="narrate-row">
        <input id="narrate-rate-input" value="0" title="Hastighet" step="25" max="100" min="-100" type="range">
      </div>
      <div id="narrate-voices" class="narrate-row"><div class="voiceselect" id="voice-select"><button class="select-toggle" aria-controls="voice-options">
      <span class="label">Röst:</span> <span class="current-voice">Standard</span>
    </button>
    <div class="options" id="voice-options" role="listbox"><button data-value="automatic" class="option selected" tabindex="-1" role="option" aria-selected="true">Standard</button><button data-value="urn:moz-tts:sapi:Microsoft Zira Desktop - English (United States)?en-US" class="option" tabindex="-1" role="option">Microsoft Zira Desktop - English (United States)</button><button data-value="automatic" class="option" tabindex="-1" role="option">Standard</button><button data-value="urn:moz-tts:sapi:Microsoft Zira Desktop - English (United States)?en-US" class="option" tabindex="-1" role="option">Microsoft Zira Desktop - English (United States)</button></div></div></div>
      <div class="dropdown-arrow"></div>
    </li></ul><button class="button" style="background-image: url('chrome://pocket/content/panels/img/pocket.svg#pocket-mark')" id="pocket-button" title="Spara till Pocket"></button></ul>




</body></html>